package workflow

import (
	"context"
	"fmt"

	v1alpha12 "github.com/argoproj/argo/pkg/apis/workflow/v1alpha1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/Azure/Orkestra/api/v1alpha1"
	"github.com/go-logr/logr"
)

type EngineType string

const (
	Forward EngineType = "forward"
	Reverse            = "reverse"
)

var _ = ForwardEngine{}
var _ = ReverseEngine{}

type Engine interface {
	// Generate the object required by the workflow engine
	Generate(ctx context.Context) error
	// Submit the object required by the workflow engine generated by the Generate method
	Submit(ctx context.Context) error

	GetLogger() logr.Logger
}

type EngineOptions struct {
	parallelism *int64
	stagingRepo string
}

type EngineBuilder struct {
	client     client.Client
	logger     logr.Logger
	engineType EngineType
	options    EngineOptions

	nodes           map[string]v1alpha12.NodeStatus
	forwardWorkflow *v1alpha12.Workflow
	appGroup        *v1alpha1.ApplicationGroup
}

type ForwardEngine struct {
	client.Client
	logr.Logger
	EngineOptions

	workflow *v1alpha12.Workflow
	appGroup *v1alpha1.ApplicationGroup
}

type ReverseEngine struct {
	client.Client
	logr.Logger
	EngineOptions

	nodes           map[string]v1alpha12.NodeStatus
	forwardWorkflow *v1alpha12.Workflow
	reverseWorkflow *v1alpha12.Workflow
}

func NewEngineBuilder(client client.Client, logger logr.Logger) *EngineBuilder {
	return &EngineBuilder{
		client:  client,
		logger:  logger,
		options: EngineOptions{},
	}
}

func (builder *EngineBuilder) Forward(appGroup *v1alpha1.ApplicationGroup) *EngineBuilder {
	builder.engineType = Forward
	builder.appGroup = appGroup
	return builder
}

func (builder *EngineBuilder) Reverse(forwardWorkflow *v1alpha12.Workflow, nodes map[string]v1alpha12.NodeStatus) *EngineBuilder {
	builder.engineType = Reverse
	builder.forwardWorkflow = forwardWorkflow
	builder.nodes = nodes
	return builder
}

func (builder *EngineBuilder) WithParallelism(numNodes int64) *EngineBuilder {
	builder.options.parallelism = &numNodes
	return builder
}

func (builder *EngineBuilder) WithStagingRepo(stagingUrl string) *EngineBuilder {
	builder.options.stagingRepo = stagingUrl
	return builder
}

func (builder *EngineBuilder) Build() (Engine, error) {
	switch builder.engineType {
	case Forward:
		return ForwardEngine{
			Client:        builder.client,
			Logger:        builder.logger,
			EngineOptions: builder.options,
			appGroup:      builder.appGroup,
		}, nil
	case Reverse:
		return ReverseEngine{
			Client:          builder.client,
			Logger:          builder.logger,
			EngineOptions:   builder.options,
			forwardWorkflow: builder.forwardWorkflow,
			nodes:           builder.nodes,
		}, nil
	}
	return nil, fmt.Errorf("failed to build engine becasue type wasn't specified")
}

func Run(ctx context.Context, engine Engine) error {
	if err := engine.Generate(ctx); err != nil {
		engine.GetLogger().Error(err, "engine failed to generate workflow")
		return fmt.Errorf("failed to generate workflow : %w", err)
	}
	if err := engine.Submit(ctx); err != nil {
		engine.GetLogger().Error(err, "engine failed to submit reverse workflow")
		return err
	}
	return nil
}

func initWorkflowObject(parallelism *int64) *v1alpha12.Workflow {
	return &v1alpha12.Workflow{
		ObjectMeta: v1.ObjectMeta{
			Labels: map[string]string{HeritageLabel: Project},
		},
		TypeMeta: v1.TypeMeta{
			APIVersion: v1alpha12.WorkflowSchemaGroupVersionKind.GroupVersion().String(),
			Kind:       v1alpha12.WorkflowSchemaGroupVersionKind.Kind,
		},
		Spec: v1alpha12.WorkflowSpec{
			Entrypoint:  EntrypointTemplateName,
			Templates:   make([]v1alpha12.Template, 0),
			Parallelism: parallelism,
			PodGC: &v1alpha12.PodGC{
				Strategy: v1alpha12.PodGCOnWorkflowCompletion,
			},
		},
	}
}

func updateWorkflowTemplates(wf *v1alpha12.Workflow, tpls ...v1alpha12.Template) {
	wf.Spec.Templates = append(wf.Spec.Templates, tpls...)
}
